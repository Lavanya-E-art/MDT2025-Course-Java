

## üß† **Theory Section ‚Äî Java Concurrency**

---

### **1Ô∏è‚É£ Comparison of Concurrency Models**

| **Model**                          | **Description**                                                                                           | **Pros (Advantages)**                                                                                                         | **Cons (Disadvantages)**                                                                            |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **Thread-based Model**             | Multiple threads share the same memory and communicate via shared variables (synchronized).               | ‚Äì High performance for shared memory systems.<br>‚Äì Easy for small-scale apps.<br>‚Äì Direct OS thread mapping.                  | ‚Äì Hard to debug (deadlocks, race conditions).<br>‚Äì Synchronization overhead.<br>‚Äì Poor scalability. |
| **Message-Passing Model**          | Threads (or processes) communicate only by sending messages, not by sharing data (e.g., `BlockingQueue`). | ‚Äì No shared state ‚Üí fewer race conditions.<br>‚Äì Easier reasoning about program flow.<br>‚Äì Scales well in distributed systems. | ‚Äì Message latency can slow down performance.<br>‚Äì Harder to coordinate complex interactions.        |
| **Actor Model**                    | Independent ‚Äúactors‚Äù each have their own state and communicate asynchronously (used in Akka, Erlang).     | ‚Äì Extremely scalable.<br>‚Äì No locks needed.<br>‚Äì Ideal for large distributed systems.                                         | ‚Äì Harder debugging and exception handling.<br>‚Äì Requires framework/library.                         |
| **Thread Pool / ExecutorService**  | A fixed number of worker threads execute queued tasks.                                                    | ‚Äì Reuses threads ‚Üí less overhead.<br>‚Äì Prevents system overload.<br>‚Äì Built-in management in Java.                            | ‚Äì Queues can still block.<br>‚Äì Tuning pool size required.                                           |
| **Virtual Threads (Project Loom)** | Lightweight, user-managed threads (Java 21+).                                                             | ‚Äì Millions of threads possible.<br>‚Äì Simplified concurrency model.<br>‚Äì Non-blocking by design.                               | ‚Äì Newer feature, limited ecosystem tools.<br>‚Äì Not yet widely adopted in older systems.             |

---

### **2Ô∏è‚É£ Concurrency vs Parallelism**

| **Aspect**       | **Concurrency**                                                | **Parallelism**                                                        |
| ---------------- | -------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **Meaning**      | Managing multiple tasks that *overlap in time* (interleaving). | Executing multiple tasks *at the same instant* on multiple processors. |
| **Goal**         | To improve responsiveness and structure.                       | To improve performance and throughput.                                 |
| **Example**      | Switching between tasks on a single CPU (multithreading).      | Running matrix multiplication on multiple cores.                       |
| **Analogy**      | A single waiter serving many tables (switching attention).     | Many waiters serving many tables simultaneously.                       |
| **Java Example** | Using `Thread` or `ExecutorService`.                           | Using `parallelStream()` or `ForkJoinPool`.                            |

**Code Example (for report):**

```java
// Concurrency Example
Thread t1 = new Thread(() -> System.out.println("Task 1"));
Thread t2 = new Thread(() -> System.out.println("Task 2"));
t1.start(); t2.start(); // Tasks overlap (interleaved)
```

```java
// Parallelism Example
int sum = IntStream.range(1, 1_000_000)
                   .parallel()
                   .sum();
System.out.println("Parallel sum: " + sum);
```

---

### **3Ô∏è‚É£ Blocking vs Non-blocking Concurrency Algorithms**

#### **üîπ Blocking Algorithms**

* The thread *waits* (is blocked) until the resource is available.
* Example: `BlockingQueue.put()`, `synchronized`, `wait()`, `Semaphore.acquire()`.
* Good for **controlled resource access**, but can lead to **thread starvation** or **deadlocks**.

**Code Example (Blocking):**

```java
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(2);

new Thread(() -> {
  try {
    for (int i = 0; i < 5; i++) {
      queue.put(i); // blocks if full
      System.out.println("Produced: " + i);
    }
  } catch (InterruptedException e) {}
}).start();

new Thread(() -> {
  try {
    while (true)
      System.out.println("Consumed: " + queue.take()); // blocks if empty
  } catch (InterruptedException e) {}
}).start();
```

#### **üîπ Non-blocking Algorithms**

* Threads *never wait* for locks or conditions.
* Uses **atomic operations** (CAS ‚Äî Compare And Swap).
* Example: `AtomicInteger`, `ConcurrentLinkedQueue`.
* Better for **high performance** systems with frequent updates.

**Code Example (Non-blocking):**

```java
AtomicInteger counter = new AtomicInteger(0);

Runnable increment = () -> {
  for (int i = 0; i < 1000; i++)
    counter.incrementAndGet(); // Non-blocking atomic increment
};

Thread t1 = new Thread(increment);
Thread t2 = new Thread(increment);
t1.start(); t2.start();
try { t1.join(); t2.join(); } catch (InterruptedException e) {}
System.out.println("Final count = " + counter.get());
```

| **Comparison**      | **Blocking**                 | **Non-Blocking**                     |
| ------------------- | ---------------------------- | ------------------------------------ |
| **Waits for locks** | Yes                          | No                                   |
| **Speed**           | Slower                       | Faster (atomic ops)                  |
| **Deadlock risk**   | Yes                          | None                                 |
| **CPU usage**       | Lower                        | Higher (busy-wait)                   |
| **Example classes** | `BlockingQueue`, `Semaphore` | `AtomicInteger`, `ConcurrentHashMap` |

---

### **4Ô∏è‚É£ Simulation Description (Conceptual Overview)**

The simulation demonstrates **real-world concurrency**:

* There are **N charging stations**.
* Multiple **AGVs (Automated Guided Vehicles)** arrive at **random times**.
* If all stations are busy, AGVs wait in a **queue**.
* If an AGV‚Äôs **waiting time > 15 min**, it leaves.
* Uses:

  * `ExecutorService` ‚Üí to handle concurrent charging threads.
  * `Semaphore` ‚Üí to represent limited charging stations.
  * `ConcurrentLinkedQueue` ‚Üí to handle arrivals safely.
  * `Random` ‚Üí to simulate variable arrival times.

---

### **5Ô∏è‚É£ Summary**

| **Topic**      | **Key Idea**                                                                |
| -------------- | --------------------------------------------------------------------------- |
| Concurrency    | Multiple tasks *appear* to run together (interleaved).                      |
| Parallelism    | Tasks *actually* run simultaneously.                                        |
| Blocking       | Waits for conditions/resources.                                             |
| Non-Blocking   | Continues without waiting; uses atomic operations.                          |
| AGV Simulation | Demonstrates resource sharing & queue management using concurrency in Java. |


