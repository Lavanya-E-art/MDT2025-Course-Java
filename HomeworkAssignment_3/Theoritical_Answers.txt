

### 1. **Comparison of Concurrency Models in Java (Pros & Cons)**

Java provides several ways to handle concurrency, from simple thread-based models to more advanced frameworks like the **Executor Framework** and **Fork/Join Framework**. Let's look at some common concurrency models used in Java.

#### a) **Thread-based Concurrency (Using `Thread` Class or `Runnable` Interface)**

* **How It Works**: In Java, concurrency can be implemented by creating instances of `Thread` or implementing the `Runnable` interface. Each thread represents a separate path of execution, running concurrently with others.

* **Pros**:

  * Simple to implement; just create a `Thread` object and start it, or implement a `Runnable` and pass it to a thread.
  * Fine-grained control over thread behavior (e.g., `Thread.sleep()`, `Thread.yield()`).

* **Cons**:

  * Managing multiple threads manually can be error-prone, leading to issues like deadlocks, race conditions, and thread starvation.
  * Threads are heavy-weight; creating a large number of threads consumes a significant amount of system resources (memory, CPU).
  * Synchronization can be complex when dealing with shared resources.

#### b) **Executor Framework (Using `Executor`, `ExecutorService`, `ThreadPoolExecutor`)**

* **How It Works**: The Executor Framework abstracts away the complexities of managing threads. It allows you to submit tasks (usually implementing `Runnable` or `Callable`) to an `ExecutorService`, which will manage the pool of threads for you. Common implementations are `ThreadPoolExecutor`, `ScheduledThreadPoolExecutor`, etc.

* **Pros**:

  * Reduces the complexity of manually creating and managing threads.
  * Allows for better resource management through a thread pool (limits the number of threads created).
  * Supports asynchronous task execution and scheduling.
  * Scalable and efficient as it reuses threads in the pool rather than constantly creating and destroying threads.

* **Cons**:

  * Requires understanding of the thread pool concepts, task queuing, and shutdown behavior.
  * May require additional tuning of parameters like the pool size for optimal performance.
  * Less control over individual threads compared to direct use of `Thread` class.

#### c) **Fork/Join Framework (Using `ForkJoinPool`)**

* **How It Works**: The Fork/Join Framework is designed for parallelism in Java. It divides tasks into smaller sub-tasks that can be processed concurrently, then joins the results. It’s particularly useful for divide-and-conquer algorithms.

* **Pros**:

  * Automatically manages work-stealing between threads, making it efficient for CPU-bound tasks.
  * Well-suited for recursive parallelism (e.g., tasks that can be split into smaller sub-tasks and processed in parallel).
  * Efficient thread management (based on a work-stealing algorithm to balance the load across threads).

* **Cons**:

  * Not ideal for tasks that do not lend themselves to being divided into smaller sub-tasks (e.g., I/O-bound tasks).
  * Complexity increases with larger numbers of tasks, especially in dealing with recursive task splitting.
  * May require significant tuning for large-scale problems.

#### d) **Java's `CompletableFuture` (Asynchronous Programming)**

* **How It Works**: Introduced in Java 8, `CompletableFuture` allows you to write non-blocking, asynchronous code. It represents a future result of an asynchronous computation that may not be available yet.

* **Pros**:

  * Allows handling asynchronous tasks without needing to write callback hell (as seen with traditional callbacks or `Future`).
  * Supports chaining of operations, allowing you to easily define complex workflows.
  * Easy integration with `ExecutorService` to run tasks asynchronously.

* **Cons**:

  * Still requires careful management to avoid potential pitfalls, like handling errors or dealing with thread contention.
  * Can lead to complex code if the execution flow is not carefully designed.

---

### 2. **Concurrency vs Parallelism in Java**

#### a) **Concurrency in Java**

* **Definition**: Concurrency in Java involves managing multiple tasks in an overlapping period. The tasks may not necessarily run at the same time but will be executed in a way that makes progress on all tasks over time.

* **Example in Java**:

  * **Managing Multiple Requests**: Using `ExecutorService` to handle multiple incoming HTTP requests. While one thread is blocked waiting for a database query, another thread might be processing a different request.
  * Java’s concurrency model allows you to handle many tasks concurrently, even though they may run on a single thread or a few threads.

* **Concurrency Tools in Java**:

  * `Thread`
  * `ExecutorService`
  * `ForkJoinPool`
  * `CompletableFuture`

#### b) **Parallelism in Java**

* **Definition**: Parallelism in Java refers to running multiple tasks simultaneously, typically on multiple CPU cores. This is useful for CPU-bound tasks where computation can be done in parallel to speed up processing.

* **Example in Java**:

  * **Parallel Computation**: Using `ForkJoinPool` to divide a large array into smaller sub-arrays, then processing them concurrently in parallel (divide and conquer).
  * Parallelism is achieved in Java when you explicitly leverage frameworks like `ForkJoinPool`, or when running on hardware with multiple processors.

* **Parallelism Tools in Java**:

  * `ForkJoinPool`
  * `Stream API` (with parallel streams, i.e., `myList.parallelStream()`)

**Key Difference**:

* **Concurrency** in Java means the ability to handle multiple tasks in a way that they progress independently (could be on a single core).
* **Parallelism** in Java means actually executing tasks at the same time, usually on multiple cores.

### 3. **Blocking vs Non-blocking Concurrency Algorithms in Java**

#### a) **Blocking Concurrency Algorithms in Java**

* **Definition**: A blocking algorithm in Java causes the thread to wait (block) until a particular condition is met, such as waiting for I/O operations to complete.

* **Common Blocking Operations in Java**:

  * I/O operations (`FileInputStream.read()`, `SocketInputStream.read()`)
  * Synchronized methods (`synchronized` blocks or methods that lock resources)
  * `Thread.sleep()` or `wait()`, `join()`, etc., that make threads pause.

* **Usage**:

  * **File I/O**: A thread may block while reading from or writing to a file.
  * **Database Access**: A thread may block while waiting for a database result.

* **Pros**:

  * Simple to implement and understand.
  * Easier to reason about since the control flow is sequential.

* **Cons**:

  * Inefficient for I/O-bound tasks, as the thread spends time idle, wasting system resources.
  * Poor scalability with high concurrency because threads are blocked and unavailable to process other tasks.

#### b) **Non-blocking Concurrency Algorithms in Java**

* **Definition**: Non-blocking algorithms in Java allow threads to continue executing other tasks while waiting for I/O operations or other conditions to be met. This is typically done with asynchronous programming models like callbacks or `Future`/`CompletableFuture`.

* **Common Non-blocking Operations in Java**:

  * **Asynchronous I/O**: Non-blocking I/O operations in Java NIO (New I/O) or using `CompletableFuture` to handle tasks asynchronously.
  * `CompletableFuture` allows for non-blocking I/O and computation tasks by returning a `Future` object that you can use to attach further operations (callbacks) that are executed once the task completes.

* **Usage**:

  * **Asynchronous Web Server**: Using `CompletableFuture` or `ExecutorService` to handle HTTP requests asynchronously, where the thread isn’t blocked while waiting for a database or network request.

* **Pros**:

  * Highly efficient for I/O-bound tasks (e.g., web servers, network servers) because threads are not blocked while waiting.
  * Allows for better scalability and more responsive systems, as threads can continue processing other tasks.

* **Cons**:

  * More complex to implement, particularly with error handling and callback chains.
  * Debugging can be challenging due to the asynchronous nature of code execution.

---

### Summary for Java:

* **Thread-based Concurrency** gives you full control over threads but can be error-prone and resource-heavy.
* **Executor Framework** provides a cleaner and more scalable way to manage thread pools.
* **Fork/Join Framework** is optimal for divide-and-conquer parallelism, and **CompletableFuture** offers easy-to-use non-blocking concurrency.
* **Concurrency** in Java manages multiple tasks in an overlapping manner, while **parallelism** runs tasks simultaneously across multiple cores.
* **Blocking algorithms** are simpler but less efficient, while **non-blocking algorithms** are more efficient but require more complex management.



⚡ Thread Coordination Summary
Code Part	Meaning	Thread Behavior
synchronized(queue)	Lock queue	Only one thread can access it at a time
queue.wait()	Pause until notified	Wait for new AGV arrival
queue.notifyAll()	Wakes up waiting threads	Done by AGV generator
station.occupy()	Lock station	Only one AGV per station
Thread.sleep()	Simulate charging	Thread pauses while others continue
station.release()	Free station	Ready for next AGV


